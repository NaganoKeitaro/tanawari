// 棚割管理システム - 自動化サービス
// ルールA/B/Cの実装

import type {
    Product,
    StandardPlanogram,
    StandardPlanogramProduct,
    StorePlanogram,
    StorePlanogramProduct,
    GenerationResult
} from '../data/types';
import {
    productRepository,
    standardPlanogramRepository,
    storePlanogramRepository,
    storeRepository,
    storeFixturePlacementRepository,
    fixtureRepository
} from '../data/repositories/localStorageRepository';

/**
 * 店舗の棚総幅を計算
 * fixtureTypeが指定された場合は、そのタイプの什器のみを集計する
 */
async function getStoreTotalWidth(storeId: string, fixtureType?: string): Promise<{ totalWidth: number; totalShelfCount: number }> {
    const placements = await storeFixturePlacementRepository.query(p => p.storeId === storeId);
    const fixtures = await fixtureRepository.getAll();

    let totalWidth = 0;
    let totalShelfCount = 0;

    for (const placement of placements) {
        const fixture = fixtures.find(f => f.id === placement.fixtureId);
        if (fixture) {
            // fixtureTypeでのフィルタリング
            // 指定がない場合は全て、指定がある場合は一致するもののみ
            // または、グループとして扱うべきか？現状は厳密一致とする（エディタの表示単位に合わせる）
            if (fixtureType && fixture.fixtureType !== fixtureType) {
                continue;
            }

            totalWidth += fixture.width;
            totalShelfCount = Math.max(totalShelfCount, fixture.shelfCount);
        }
    }

    return { totalWidth, totalShelfCount };
}

/**
 * ルールA: カット処理 (店舗の棚 < 標準)
 * 売上ランクが低い商品から、フェイス数を減らす→削除
 */
function applyRuleA(
    products: StandardPlanogramProduct[],
    productMaster: Product[],
    targetWidth: number
): { products: StorePlanogramProduct[]; warnings: string[] } {
    const warnings: string[] = [];

    // 商品を売上ランクでソート（高い=悪い順）
    const sortedProducts = [...products].sort((a, b) => {
        const prodA = productMaster.find(p => p.id === a.productId);
        const prodB = productMaster.find(p => p.id === b.productId);
        return (prodB?.salesRank || 100) - (prodA?.salesRank || 100); // 高いランク（悪い）から
    });

    const result: StorePlanogramProduct[] = [];

    // 段ごとに処理
    const shelfIndices = [...new Set(sortedProducts.map(p => p.shelfIndex))];

    for (const shelfIndex of shelfIndices) {
        let shelfProducts = sortedProducts.filter(p => p.shelfIndex === shelfIndex);
        let currentWidth = 0;

        // まず全商品を追加して幅を計算
        for (const sp of shelfProducts) {
            const product = productMaster.find(p => p.id === sp.productId);
            if (!product) continue;
            currentWidth += product.width * sp.faceCount;
        }

        // 幅がオーバーしている場合、ランクの低い順にフェイス削減/カット
        while (currentWidth > targetWidth && shelfProducts.length > 0) {
            // ランクが最も低い（値が大きい）商品を取得
            const worstProduct = shelfProducts[0];
            const product = productMaster.find(p => p.id === worstProduct.productId);

            if (!product) {
                shelfProducts = shelfProducts.slice(1);
                continue;
            }

            if (worstProduct.faceCount > 1) {
                // フェイス数を減らす
                worstProduct.faceCount -= 1;
                currentWidth -= product.width;
                warnings.push(`${product.name}: フェイス数を削減 (${worstProduct.faceCount + 1} → ${worstProduct.faceCount})`);
            } else {
                // 削除（カット）
                shelfProducts = shelfProducts.slice(1);
                currentWidth -= product.width;
                warnings.push(`${product.name}: カット（売上ランク ${product.salesRank}）`);
            }
        }

        // 結果に追加
        let posX = 0;
        for (const sp of shelfProducts) {
            const product = productMaster.find(p => p.id === sp.productId);
            if (!product) continue;

            result.push({
                id: crypto.randomUUID(),
                productId: sp.productId,
                shelfIndex: sp.shelfIndex,
                positionX: posX,
                faceCount: sp.faceCount,
                isAutoGenerated: true,
                isCut: false
            });
            posX += product.width * sp.faceCount;
        }
    }

    return { products: result, warnings };
}

/**
 * ルールB: 拡張処理 (店舗の棚 > 標準)
 * トップ10商品のフェイス数を2倍→1.5倍→余白
 */
function applyRuleB(
    products: StandardPlanogramProduct[],
    productMaster: Product[],
    targetWidth: number,
    _standardWidth: number
): { products: StorePlanogramProduct[]; warnings: string[] } {
    const warnings: string[] = [];

    // 売上ランク上位10を抽出
    const rankedProducts = products
        .map(p => ({
            ...p,
            salesRank: productMaster.find(pm => pm.id === p.productId)?.salesRank || 100
        }))
        .sort((a, b) => a.salesRank - b.salesRank)
        .slice(0, 10);

    const top10Ids = new Set(rankedProducts.map(p => p.productId));

    // 段ごとに処理
    const shelfIndices = [...new Set(products.map(p => p.shelfIndex))];
    const result: StorePlanogramProduct[] = [];

    for (const shelfIndex of shelfIndices) {
        const shelfProducts = products.filter(p => p.shelfIndex === shelfIndex);
        let posX = 0;

        for (const sp of shelfProducts) {
            const product = productMaster.find(p => p.id === sp.productId);
            if (!product) continue;

            let newFaceCount = sp.faceCount;

            // トップ10の場合、フェイス数拡張を試みる
            if (top10Ids.has(sp.productId)) {
                const currentUsed = shelfProducts.reduce((sum, p) => {
                    const prod = productMaster.find(pm => pm.id === p.productId);
                    return sum + (prod ? prod.width * p.faceCount : 0);
                }, 0);

                const available = targetWidth - currentUsed;
                const extraNeeded = product.width * sp.faceCount; // 2倍にするために必要な追加幅

                if (available >= extraNeeded) {
                    // 2倍可能
                    newFaceCount = sp.faceCount * 2;
                    warnings.push(`${product.name}: フェイス2倍 (${sp.faceCount} → ${newFaceCount})`);
                } else if (available >= extraNeeded * 0.5) {
                    // 1.5倍で妥協
                    newFaceCount = Math.floor(sp.faceCount * 1.5);
                    if (newFaceCount > sp.faceCount) {
                        warnings.push(`${product.name}: フェイス1.5倍 (${sp.faceCount} → ${newFaceCount})`);
                    }
                }
                // それ以外は変更なし（余白として残す）
            }

            result.push({
                id: crypto.randomUUID(),
                productId: sp.productId,
                shelfIndex: sp.shelfIndex,
                positionX: posX,
                faceCount: newFaceCount,
                isAutoGenerated: true,
                isCut: false
            });
            posX += product.width * newFaceCount;
        }

        // 残り幅を警告として記録
        const finalUsed = result.filter(r => r.shelfIndex === shelfIndex).reduce((sum, r) => {
            const prod = productMaster.find(p => p.id === r.productId);
            return sum + (prod ? prod.width * r.faceCount : 0);
        }, 0);

        if (targetWidth - finalUsed > 10) {
            warnings.push(`段${shelfIndex + 1}: ${targetWidth - finalUsed}cmの余白あり`);
        }
    }

    return { products: result, warnings };
}

/**
 * 個店棚割を自動生成
 */
export async function generateStorePlanogram(
    storeId: string,
    standardPlanogram: StandardPlanogram
): Promise<GenerationResult> {
    const store = await storeRepository.getById(storeId);
    if (!store) {
        return {
            storeId,
            storeName: '不明',
            status: 'error',
            message: '店舗が見つかりません'
        };
    }

    try {
        // 店舗の棚情報を取得（標準棚割のタイプに一致するもののみ）
        const { totalWidth, totalShelfCount } = await getStoreTotalWidth(storeId, standardPlanogram.fixtureType);

        if (totalWidth === 0) {
            // このタイプの什器がない場合、エラーにはせずワーニングか、あるいはスキップメッセージを返す
            return {
                storeId,
                storeName: store.name,
                status: 'warning',
                message: `店舗に${standardPlanogram.fixtureType || '指定'}タイプの什器が配置されていません`
            };
        }

        const productMaster = await productRepository.getAll();

        let result: { products: StorePlanogramProduct[]; warnings: string[] };

        // サイズ比較してルールA or Bを適用
        if (totalWidth < standardPlanogram.width) {
            // ルールA: カット
            result = applyRuleA(standardPlanogram.products, productMaster, totalWidth);
        } else if (totalWidth > standardPlanogram.width) {
            // ルールB: 拡張
            result = applyRuleB(standardPlanogram.products, productMaster, totalWidth, standardPlanogram.width);
        } else {
            // 同じサイズ: そのままコピー
            result = {
                products: standardPlanogram.products.map(p => ({
                    id: crypto.randomUUID(),
                    productId: p.productId,
                    shelfIndex: p.shelfIndex,
                    positionX: p.positionX,
                    faceCount: p.faceCount,
                    isAutoGenerated: true,
                    isCut: false
                })),
                warnings: []
            };
        }

        // 既存の個店棚割を検索
        const existing = await storePlanogramRepository.query(
            p => p.storeId === storeId && p.standardPlanogramId === standardPlanogram.id
        );

        const planogramData: Omit<StorePlanogram, 'id'> = {
            storeId,
            standardPlanogramId: standardPlanogram.id,
            width: totalWidth,
            height: standardPlanogram.height,
            shelfCount: totalShelfCount || standardPlanogram.shelfCount,
            products: result.products,
            status: result.warnings.length > 0 ? 'warning' : 'generated',
            warnings: result.warnings,
            createdAt: existing[0]?.createdAt || new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            syncedAt: new Date().toISOString()
        };

        if (existing.length > 0) {
            await storePlanogramRepository.update(existing[0].id, planogramData);
        } else {
            await storePlanogramRepository.create(planogramData);
        }

        return {
            storeId,
            storeName: store.name,
            status: result.warnings.length > 0 ? 'warning' : 'generated',
            message: result.warnings.length > 0
                ? `${result.warnings.length}件の調整あり`
                : '正常に生成されました'
        };
    } catch (error) {
        return {
            storeId,
            storeName: store.name,
            status: 'error',
            message: error instanceof Error ? error.message : '不明なエラー'
        };
    }
}

/**
 * FMTの全店舗に対して一括生成
 */
export async function batchGenerateStorePlanograms(
    standardPlanogram: StandardPlanogram,
    onProgress?: (current: number, total: number, result: GenerationResult) => void
): Promise<GenerationResult[]> {
    const stores = await storeRepository.query(s => s.fmt === standardPlanogram.fmt);
    const results: GenerationResult[] = [];

    for (let i = 0; i < stores.length; i++) {
        const store = stores[i];
        const result = await generateStorePlanogram(store.id, standardPlanogram);
        results.push(result);
        onProgress?.(i + 1, stores.length, result);
    }

    return results;
}

/**
 * ルールC: 同期
 * 親の最新状態でルールA/Bを再適用
 */
export async function syncStorePlanogram(
    storePlanogramId: string
): Promise<GenerationResult> {
    const storePlanogram = await storePlanogramRepository.getById(storePlanogramId);
    if (!storePlanogram) {
        return {
            storeId: '',
            storeName: '',
            status: 'error',
            message: '個店棚割が見つかりません'
        };
    }

    const standardPlanogram = await standardPlanogramRepository.getById(storePlanogram.standardPlanogramId);
    if (!standardPlanogram) {
        return {
            storeId: storePlanogram.storeId,
            storeName: '',
            status: 'error',
            message: '標準棚割が見つかりません'
        };
    }

    return generateStorePlanogram(storePlanogram.storeId, standardPlanogram);
}
